// Generated by dts-bundle v0.7.3

export const BPD_Flow_ver = "0.1.0";
export function counter(): Generator<number, void, unknown>;
export class FlowFactory {
    static create<T, V>(actions: Actions<T, V>): Flow<T, V>;
    static fromList<T, V>(...actions: FlowAction<T, V>[]): Flow<T, V>;
}
export class Flow<T, V> {
    actions: FlowManagers<T, V>;
    constructor(...actions: FlowAction<T, V>[]);
    subscribe(name: string, details?: TaskDetails<V>): FlowTask<V>;
    unsubscribe(name: string, id: string): void;
    perform(actionName: string, args?: T): void;
}
export interface FlowManagers<T, V> {
    [id: string]: FlowActionManager<T, V>;
}
export class FlowActionManager<T, V> {
    #private;
    constructor(action: FlowAction<T, V>);
    subscribe(task?: FlowTask<V>): FlowTask<V>;
    unsubscribe(id: TaskIdItem<V>): void;
    perform(t: T, key?: string): void;
    getStats(): any;
}
export class FlowDict<T> implements IFlowDict<T> {
    #private;
    keys: string[];
    values: T[];
    constructor(onEvent?: IFlowEventCallback);
    add(key: string, value: T): void;
    has(key: string): boolean;
    remove(key: string): void;
    get(key: string): T;
    count(): number;
    clear(): void;
    shift(): T;
    first(): T;
    removeIndex(index: number): void;
}

export interface FlowAction<T, V> {
    name: string;
    perform(t?: T): Promise<V>;
}
export type FlowEventType = "STATE" | "FAIL";
export interface IFlowEventCallback {
    (action: string, type: FlowEventType, message?: string): void;
}
export interface IFlowDict<T> {
    add(key: string, value: T): void;
    has(key: string): boolean;
    remove(key: string): void;
    get(key: string): T;
    count(): number;
    clear(): void;
    shift(): T;
    first(): T;
    removeIndex(index: number): void;
}
export interface Actions<T, V> {
    [name: string]: (t: T) => V;
}
export type TaskIdItem<T> = string | FlowTask<T>;
export interface OnFinishCallback<T> {
    (t: T): void;
}
export interface OnErrorCallback {
    (t: Error): void;
}
export interface TaskDetails<T> {
    task?: FlowTask<T>;
    finish?: OnFinishCallback<T>;
    error?: OnErrorCallback;
}

export class FlowTask<T> {
    #private;
    id: string;
    constructor(id: string);
    update(result: T, err?: Error): void;
    finish(onFinish: (t: T) => void): FlowTask<T>;
    error(onError: (e: Error) => void): FlowTask<T>;
}

