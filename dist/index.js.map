{"version":3,"sources":["webpack://cui-light/webpack/universalModuleDefinition","webpack://cui-light/webpack/bootstrap","webpack://cui-light/./src/api/invoker.ts","webpack://cui-light/./src/api/task.ts","webpack://cui-light/./src/api/action.ts","webpack://cui-light/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","FlowAsyncInvoker","action","this","subscribers","perform","then","result","all","item","update","catch","err","callback","forEach","index","FlowTask","id","onFinish","onError","Action","ctx","apply","BPD_Flow_ver","COUNTER","counter","idx","actions","list","actionName","push","getActionListFromObj","Flow","act","details","subscribe","task","finish","error","unsubscribe","args","FlowDict","flowTask","findTaskIndex","next","splice","queueKey","getKey","add","queueCount","count","subscribersCount","length","findIndex","it","param","first","invoke","resul","removeIndex","Array","isArray","JSON","stringify","onEvent","keys","values","has","publish","indexOf","shift","type","message"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"cui-light\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cui-light\"] = factory();\n\telse\n\t\troot[\"cui-light\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { FlowAction } from \"./interfaces\";\r\nimport { FlowTask } from \"./task\";\r\n\r\nexport interface FlowInvoker<T, V> {\r\n    action: FlowAction<T, V>;\r\n    invoke(t: T, subscribers: FlowTask<V>[]): Promise<boolean>;\r\n}\r\n\r\nexport class FlowAsyncInvoker<T, V> implements FlowInvoker<T, V> {\r\n    action: FlowAction<T, V>;\r\n    constructor(action: FlowAction<T, V>) {\r\n        this.action = action;\r\n    }\r\n\r\n    async invoke(t: T, subscribers: FlowTask<V>[]): Promise<boolean> {\r\n        let p = this.action.perform(t).then((result: V) => {\r\n            this.all(subscribers, (item) => {\r\n                item.update(result);\r\n            })\r\n        }).catch((err: Error) => {\r\n            this.all(subscribers, (item) => {\r\n                item.update(null, err);\r\n            })\r\n        })\r\n\r\n        await p;\r\n        return true;\r\n    }\r\n\r\n    private all(subscribers: FlowTask<V>[], callback: (item: FlowTask<V>, index: number) => void) {\r\n        subscribers.forEach((item: FlowTask<V>, index: number) => {\r\n            callback(item, index);\r\n        })\r\n    }\r\n}","export class FlowTask<T> {\r\n    #onFinish: (t: T) => void;\r\n    #onError: (e: Error) => void;\r\n    id: string;\r\n\r\n    constructor(id: string) {\r\n        this.#onError = null;\r\n        this.#onFinish = null;\r\n        this.id = \"FlowTask-\" + id;\r\n    }\r\n\r\n    update(result: T, err?: Error) {\r\n        if (err && this.#onError) {\r\n            this.#onError(err)\r\n        } else if (result && this.#onFinish) {\r\n            this.#onFinish(result);\r\n        }\r\n    }\r\n\r\n    finish(onFinish: (t: T) => void): FlowTask<T> {\r\n        this.#onFinish = onFinish;\r\n        return this;\r\n    }\r\n\r\n    error(onError: (e: Error) => void): FlowTask<T> {\r\n        this.#onError = onError;\r\n        return this;\r\n    }\r\n}","import { FlowAction, Actions } from \"./interfaces\";\r\n\r\nexport class Action<T, V> implements FlowAction<T, V> {\r\n    name: string;\r\n    #callback: (t: T) => V;\r\n    #ctx: any;\r\n    constructor(name: string, callback: (t: T) => V, ctx?: any) {\r\n        this.name = name;\r\n        this.#callback = callback;\r\n        this.#ctx = ctx;\r\n    }\r\n\r\n    async perform(t?: T): Promise<V> {\r\n        if (this.#callback) {\r\n            return this.#ctx ? this.#callback.apply(this.#ctx, t) : this.#callback(t);\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n\r\n\r\nexport function getActionListFromObj<T, V>(actions: Actions<T, V>): FlowAction<T, V>[] {\r\n    let list: FlowAction<T, V>[] = [];\r\n    for (let actionName in actions) {\r\n        if (actions.hasOwnProperty(actionName) && typeof actions[actionName] === 'function') {\r\n            list.push(new Action(actionName, actions[actionName]))\r\n        }\r\n    }\r\n    return list;\r\n}","import { FlowAction, IFlowDict, IFlowEventCallback, FlowEventType, Actions, TaskIdItem, TaskDetails } from \"./api/interfaces\";\r\nimport { FlowInvoker, FlowAsyncInvoker } from \"./api/invoker\";\r\nimport { FlowTask } from \"./api/task\";\r\nimport { getActionListFromObj } from \"./api/action\";\r\n\r\nexport const BPD_Flow_ver = \"0.1.0\";\r\n\r\nconst COUNTER = counter();\r\n\r\nexport { FlowAction } from \"./api/interfaces\";\r\n\r\nexport function* counter() {\r\n    let idx = 0;\r\n    while (true) {\r\n        let reset = yield idx++;\r\n        if (reset || idx > 200000) {\r\n            idx = 0\r\n        }\r\n    }\r\n}\r\n\r\nexport class FlowFactory {\r\n    static create<T, V>(actions: Actions<T, V>): Flow<T, V> {\r\n        let list = getActionListFromObj(actions);\r\n        return new Flow(...list);\r\n    }\r\n\r\n    static fromList<T, V>(...actions: FlowAction<T, V>[]): Flow<T, V> {\r\n        return new Flow(...actions);\r\n    }\r\n}\r\n\r\nexport class Flow<T, V> {\r\n    actions: FlowManagers<T, V>;\r\n    constructor(...actions: FlowAction<T, V>[]) {\r\n        this.actions = {};\r\n        actions.forEach(act => {\r\n            this.actions[act.name] = new FlowActionManager(act);\r\n        })\r\n    }\r\n\r\n    subscribe(name: string, details?: TaskDetails<V>): FlowTask<V> {\r\n        let action = this.actions[name];\r\n        if (!action) {\r\n            return null;\r\n        }\r\n        if (!details) {\r\n            return action.subscribe();\r\n        }\r\n        let task = action.subscribe(details.task);\r\n        if (details.finish) {\r\n            task.finish(details.finish);\r\n        }\r\n        if (details.error) {\r\n            task.error(details.error);\r\n        }\r\n        return task;\r\n    }\r\n\r\n    unsubscribe(name: string, id: string) {\r\n        let action = this.actions[name];\r\n        if (action) {\r\n            action.unsubscribe(id);\r\n        }\r\n    }\r\n\r\n    perform(actionName: string, args?: T) {\r\n        let action = this.actions[actionName];\r\n        if (action) {\r\n            action.perform(args);\r\n        }\r\n    }\r\n}\r\n\r\nexport interface FlowManagers<T, V> {\r\n    [id: string]: FlowActionManager<T, V>;\r\n}\r\n\r\n\r\nexport class FlowActionManager<T, V> {\r\n    #subscribers: FlowTask<V>[];\r\n    #action: FlowAction<T, V>;\r\n    #isLocked: boolean;\r\n    #invoker: FlowInvoker<T, V>;\r\n    #queue: IFlowDict<T>;\r\n    constructor(action: FlowAction<T, V>) {\r\n        this.#subscribers = [];\r\n        this.#action = action;\r\n        this.#invoker = new FlowAsyncInvoker(action);\r\n        this.#queue = new FlowDict<T>();\r\n    }\r\n\r\n    subscribe(task?: FlowTask<V>): FlowTask<V> {\r\n        let flowTask = null;\r\n        if (!task) {\r\n            flowTask = new FlowTask<V>(COUNTER.next().value + \"\");\r\n        } else if (this.findTaskIndex(task.id) > -1) {\r\n            return task;\r\n        } else {\r\n            flowTask = task;\r\n        }\r\n        this.#subscribers.push(flowTask);\r\n        return flowTask;\r\n    }\r\n\r\n    unsubscribe(id: TaskIdItem<V>) {\r\n        let idx = this.findTaskIndex(id)\r\n        if (idx > -1) {\r\n            this.#subscribers.splice(idx, 1);\r\n        }\r\n    }\r\n\r\n    perform(t: T, key?: string): void {\r\n        let queueKey = key ?? this.getKey(t);\r\n        this.#queue.add(queueKey, t);\r\n        this.call();\r\n    }\r\n\r\n    getStats(): any {\r\n        return {\r\n            queueCount: this.#queue.count(),\r\n            subscribersCount: this.#subscribers.length\r\n        }\r\n    }\r\n\r\n    private findTaskIndex(task: TaskIdItem<V>): number {\r\n        let id: string = \"\";\r\n        if (typeof task === 'string') {\r\n            id = task;\r\n        } else {\r\n            id = task.id;\r\n        }\r\n        return this.#subscribers.findIndex(it => it.id === id);\r\n    }\r\n\r\n    private call() {\r\n        if (!this.#isLocked) {\r\n            this.#isLocked = true;\r\n            let param = this.#queue.first();\r\n            this.#invoker.invoke(param, this.#subscribers).then((resul) => {\r\n                this.#isLocked = false;\r\n                this.#queue.removeIndex(0);\r\n                if (this.#queue.count() > 0) {\r\n                    this.call();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private getKey(t: T): string {\r\n        if (typeof t === \"string\") {\r\n            return t;\r\n        }\r\n        if (typeof t === \"boolean\" || typeof t === \"number\") {\r\n            return t + \"\";\r\n        }\r\n        else if (Array.isArray(t)) {\r\n            return `[${t.length === 0 ? 0 : t.length}]`;\r\n        }\r\n        return JSON.stringify(t);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class FlowDict<T> implements IFlowDict<T> {\r\n    keys: string[];\r\n    values: T[];\r\n    #onEvent: IFlowEventCallback;\r\n    constructor(onEvent?: IFlowEventCallback) {\r\n        this.keys = [];\r\n        this.values = [];\r\n        this.#onEvent = onEvent;\r\n    }\r\n    add(key: string, value: T): void {\r\n        if (!this.has(key)) {\r\n            this.keys.push(key);\r\n            this.values.push(value);\r\n            this.publish(\"add\", \"STATE\", \"Key: \" + key + \" added\");\r\n            return;\r\n        }\r\n        this.publish(\"add\", \"FAIL\", \"Key: \" + key + \" exists\");\r\n    }\r\n    has(key: string): boolean {\r\n        return this.indexOf(key) > -1;\r\n    }\r\n\r\n    remove(key: string): void {\r\n        let index = this.indexOf(key);\r\n        if (index > -1) {\r\n            this.removeIndex(index);\r\n            this.publish(\"add\", \"STATE\", \"Key: \" + key + \" removed\");\r\n            return;\r\n        }\r\n        this.publish(\"add\", \"STATE\", \"Key: \" + key + \" not found\");\r\n    }\r\n\r\n    get(key: string): T {\r\n        let index = this.indexOf(key);\r\n        if (index > -1) {\r\n            return this.values[index];\r\n        }\r\n        this.publish(\"add\", \"STATE\", \"Key: \" + key + \" not found\");\r\n        return null;\r\n    }\r\n\r\n    count(): number {\r\n        return this.keys.length;\r\n    }\r\n\r\n    clear(): void {\r\n        this.keys = [];\r\n        this.values = [];\r\n        this.publish(\"clear\", \"STATE\", \"Finished\");\r\n    }\r\n\r\n    shift(): T {\r\n        this.keys.shift();\r\n        return this.values.shift();\r\n    }\r\n\r\n    first(): T {\r\n        return this.count() > 0 ? this.values[0] : null;\r\n    }\r\n\r\n    removeIndex(index: number) {\r\n        if (index > -1 && this.values.length > index) {\r\n            this.keys.splice(index, 1);\r\n            this.values.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    private indexOf(key: string): number {\r\n        return key ? this.keys.indexOf(key) : -1;\r\n    }\r\n\r\n    private publish(action: string, type: FlowEventType, message?: string) {\r\n        if (this.#onEvent) {\r\n            this.#onEvent(action, type, message);\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""}